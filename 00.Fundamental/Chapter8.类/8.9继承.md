# 继承

继承是为代码复用和设计复用而设计的，是面向对象程序设计的重要特性之一。

当我们设计一个新类时，如果可以继承一个已有的、设计良好的类，然后进行二次开发，无疑会大幅减少开发的工作量。

在继承关系中，已有的、设计好的类称为父类或基类，新设计的类称为子类或派生类。

派生类可以继承父类的公有成员，但是不能继承其私有成员。

- **子类继承父类的变量和方法**
  
- Python 的继承是 多继承，即 子类 可以 继承多个父类，其他语言一般为单继承

## 继承的实现

### 不需要外部导入

- 需要继承的类写在 类定义时的 括号中()

```python
# 没有导入的情况
class sub_class(parent_class):
    pass
```

### 需要外部导入
- 需要从外部导入时，可使用 **import** or **from import**
- 为增强代码可读性，推荐使用 **from import**

```python
# 有导入的情况

# 使用 import
import importing_file

class sub_class(importing_file.parent_class):
    pass

# 使用 from import

from importing_file import parent_class

class sub_class(parent_class):
    pass
```

## 子类的构造函数

- 子类的构造函数，应调用父类的构造函数，来初始化继承自父类的变量

- 子类的构造函数中的参数应包括self,自身变量，与继承的父类变量

- self 在第一位，自身变量的位置与继承的父类变量位置无关，但是为了方便，继承的父类变量一般写在子什么变量前边，并且在调用父类构造函数时，应将父类参数按顺序传递

```python
# 子类调用父类构造函数

class sub_class():
    # 子类构造函数
    def __init__(slef,parent_variable1,parent_variable2,...,sub_variable1,sub_variable2,...,):
        # 父类构造函数
        Parent_class_name.__init__(parent_variable1,parent_variable2,...)
        pass
```

## 方法一：用父类名字调用父类的各种方法
- Parent_name.Method_name()
  
- **非常不方便**，当父类更改时，子类中所有的父类的名字都得改变


## 方法二：**super** 关键字
> **super(sub_class.name, slef).parent_method(varaible)**

- 当父类改变时，不用每个更改调用父类方法时用到的父类名字

- 子类和父类的方法出现同名时，会调用子类方法，此时使用 **super** 关键字就可以调用父类方法
  
```python
# Human.py

class Human():

    sum = 0

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def get_info(self):
        print(self.name, self.age)

    def display(slef):
        print("This is a parent \"display\" method",) 

# Student.py
from Human import Human

class Student(Human):

    def __init__(self,name,age,school):
        # Human.__init__(self,name, age)   # 第一种方法调用 父类构造函数
        super(Student,self).__init__(name, age) # 第二方法调用 父类构造函数
        self.school = school  # school 子类自身 变量

        def display(self):
        super(Student, self).display()     # 用 super 调用 父类方法
        print("is called by Subclass")

print("ParentClass's sum = ", Student.sum)  # 子类中没有 sum，测试继承父类的 sum 是否可以打印


student1 = Student('孙悟空',999,'人民路小学')
print("通过继承父类方法打印名字 name and age = ", end = '')
student1.get_info()

print("StudentClass's school = ", student1.school)

'''
----------------------------------------
ParentClass's sum =  0
通过继承父类方法打印名字 name and age = 孙悟空 999
StudentClass's school =  人民路小学
This is a parent "display" method
is called by Subclass
-----------------------------------------
'''
```

## Summary

1. 在继承中，**基类的构造函数（\_\_init\_\_()方法）不会被自动调用**，它需要在其派生类的构造中专门调用。
   
2. 如果需要在派生类中调用基类的方法时，可通过 **基类名.方法名()** 的方式来实现，需要加上基类的类名前缀，且需要带上self参数变量，区别于在类中调用普通函数时并不需要带上self参数。也可以使用内置函数**super()**实现这一目的。
   
3. Python总是首先查找对应类型的方法，如果不能在派生类中找到对应的方法，它才会到基类中逐个查找（**先在本类中查找调用的方法，找不到才去基类中找**）

```python
# 定义基类 : Person 类
import types
class Person(object): # 基类必须继承于 object, 否则在派生类中将无法使用 super() 函数

    def __init__(self, name = "", age = 20, sex = "man"):
        self.setName(name)
        self.setAge(age)
        self.setSex(sex)

    def setName(self, name):
        if type(name) != str:   # 内置函数 type() 返回被测对象的数据类型
            print("姓名必须是字符串.")
            return
        self.__name = name

    def setAge(self, age):
        if type(age) != int:
            print("年龄必须是整型.")
            return
        self.__age = age

    def setSex(self, sex):
        if sex != '男' and sex != '女':
            print("性别输入错误")
            return
        self.__sex = sex

    def show(self):
        print("姓名：", self.__name,"年龄：", self.__age, "性别：", self.__sex)

# 定义子类 (Student 类）, 其中增加一个入学年份私有属性（数据成员）
class Student(Person):
    def __init__(self, name = "", age = 20, sex = "man", schoolyear = 2016):
        # 调用基类构造函数初始化基类的私有数据成员
        super(Student, self).__init__(name, age, sex)
        # Person.__init__(self, name, age, sex)
        # 也可以这样初始化基类私有数据成员

        self.setSchoolyear(schoolyear)  # 初始化派生类的数据成员

    def setSchoolyear(self, schoolyear):
        self.__schoolyear = schoolyear

    def show(self):
        Person.show(self)               # 调用 基类 show() 方法
        # super(Student, self).show()   # 也可以这样调用 基类 show() 方法

# 主程序
if __name__ == "__main__":
    zhangsan = Person("张三", 19, '男')
    zhangsan.show()

    lisi = Student("李四", 18, '男', 2015)
    lisi.show()
    lisi.setAge(20)     # 调用继承的方法修改年龄
    lisi.show()
```

```python
# Output
姓名： 张三 年龄： 19 性别： 男
姓名： 李四 年龄： 18 性别： 男
姓名： 李四 年龄： 20 性别： 男
```

方法重写必须出现在继承中。它是指当派生类继承了基类的方法之后，如果基类方法的功能不能满足需求，则需要对基类中的某些方法进行修改。可以在派生类重写基类的方法。

```python
class Animal:                       # 定义父类
    def run(self):
        print("Animal is running")  # 调用父类方法

class Cat(Animal):                  # 定义子类
    def run(self):
        print("Cat is running")     # 调用子类方法

class Dog(Animal):                  # 定义子类
    def run(self):
        print("Dog is running")     # 调用子类方法

c = Cat()                           # 子类实例化
c.run()                             # 子类调用重写方法

d = Dog()                           # 子类实例化
d.run()                             # 子类调用重写方法
```

```python
# Output
Cat is running
Dog is running
```

当子类Dog和父类Animal都存在相同的run()方法时，子类的run()覆盖了父类的run()。

在代码运行时，总是会调用子类的run()。这样，就获得了继承的另一个优点：多态。